<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Marco Bonifacio (Articoli su jupyter)</title><link>https://marcobonifacio.github.io/</link><description></description><atom:link href="https://marcobonifacio.github.io/categories/jupyter.xml" rel="self" type="application/rss+xml"></atom:link><language>it</language><copyright>Contents © 2021 &lt;a href="mailto:bonifacio.marco@gmail.com"&gt;Marco Bonifacio&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"&gt;
&lt;img alt="Licenza Creative Commons BY-SA"
style="border-width:0"
src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"&gt;&lt;/a&gt;&lt;br /&gt;
Quest'opera è distribuita con Licenza 
&lt;a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"&gt;
Creative Commons Attribuzione - Condividi allo stesso modo 4.0 Internazionale&lt;/a&gt;.
</copyright><lastBuildDate>Tue, 04 May 2021 16:51:21 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Python per la finanza</title><link>https://marcobonifacio.github.io/posts/python-per-la-finanza/</link><dc:creator>Marco Bonifacio</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a class="reference external" href="https://www.python.org"&gt;Python&lt;/a&gt; è per me diventato negli anni uno strumento indispensabile di lavoro, soprattutto quando i dati da gestire superano le capacità di Excel o per effettuare alcune analisi statistiche un po' più sofisticate del solito. Tuttavia, mi sono accorto che costruire un ambiente di lavoro efficace ed efficiente basato su Python non è sempre intuitivo, per cui proverò in questo post a condividere alcune delle cose che ho imparato nel tempo per giungere a una configurazione soddisfacente di questo importante strumento, soprattutto per chi lavora in ambito finanziario o ha comunque necessità di analizzare dei dati.&lt;/p&gt;
&lt;p&gt;La distribuzione di Python più interessante per chi lavora con i dati (o fa &lt;em&gt;data science&lt;/em&gt;, come si dice adesso) è sicuramente &lt;a class="reference external" href="https://www.anaconda.com/products/individual"&gt;Anaconda&lt;/a&gt;, che però installa di &lt;em&gt;default&lt;/em&gt; fin troppe librerie scientifiche per i miei gusti. Esiste una versione &lt;em&gt;minimal&lt;/em&gt; di &lt;code&gt;Anaconda&lt;/code&gt;, &lt;a class="reference external" href="https://docs.conda.io/en/latest/miniconda.html"&gt;miniconda&lt;/a&gt;, che installa solo l'interprete del linguaggio e un set minimo di librerie per il funzionamento del &lt;em&gt;package manager&lt;/em&gt;, lasciando all'utente la possibilità di installare poi solo gli ulteriori pacchetti effettivamente necessari per ciascun progetto. Qui però iniziano le difficoltà. Se da un lato &lt;code&gt;conda&lt;/code&gt;, rispetto a &lt;code&gt;pip&lt;/code&gt;, il &lt;em&gt;package manager&lt;/em&gt; ufficiale di Python, permette una gestione delle librerie più agevole, dall'altro il numnero di pacchetti disponibili è ben inferiore. Per fortuna, un'ampia &lt;em&gt;community&lt;/em&gt; si è fatta carico di ampliare la disponibilità di librerie sotto &lt;code&gt;conda&lt;/code&gt; attraverso il canale &lt;code&gt;conda-forge&lt;/code&gt;. Mischiare però le distribuzioni "ufficiali" di Anaconda con quelle di &lt;code&gt;conda-forge&lt;/code&gt; è sconsigliabile e nel tempo rischia di corrompere i vari ambienti di lavoro di Python. Per questo ho recentemente scoperto con soddifazione &lt;a class="reference external" href="https://github.com/conda-forge/miniforge"&gt;miniforge&lt;/a&gt; un clone di &lt;code&gt;miniconda&lt;/code&gt; che scarica direttamente i pacchetti di Python dal canale della &lt;em&gt;community&lt;/em&gt; di &lt;code&gt;conda-forge&lt;/code&gt; &lt;a class="footnote-reference brackets" href="https://marcobonifacio.github.io/posts/python-per-la-finanza/#id3" id="id1"&gt;1&lt;/a&gt;. Alla fine, quindi, sto usando con soddisfazione da alcuni mesi questa distribuzione, con &lt;em&gt;settings&lt;/em&gt; identici tra i vari dispositivi che utilizzo in modo da avere ambienti di lavoro intercambiabili.&lt;/p&gt;
&lt;p&gt;Passando alle librerie vere e proprie, la prima cosa da installare, secondo me, è la triade &lt;a class="reference external" href="https://numpy.org/"&gt;numpy&lt;/a&gt; - &lt;a class="reference external" href="https://pandas.pydata.org/"&gt;pandas&lt;/a&gt; - &lt;a class="reference external" href="https://matplotlib.org/"&gt;matplotlib&lt;/a&gt;. Altamente integrati tra loro, questi tre pacchetti soddisfano tutte le esigenze di analisi e visualizzazione dei dati, sostituendo più che degnamente gli enormi fogli Excel con centinaia di collegamenti che vanno velocemente fuori controllo. A questa configurazione base si possono poi aggiungere numerose altre librerie più specializzate, tra cui, ad esempio, &lt;a class="reference external" href="https://www.scipy.org/"&gt;scipy&lt;/a&gt; per le procedure di ottimizzazione o &lt;a class="reference external" href="https://scikit-learn.org/stable/"&gt;scikit-learn&lt;/a&gt; per classificazione e regressione (o - più pomposamente - per il &lt;em&gt;machine learning&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Tutto questo può essere gestito tramite un normale &lt;em&gt;editor&lt;/em&gt; di testo o l'interprete interattivo di Python, ma è probabilmente più comodo fare le prime analisi di un progetto attraverso un &lt;em&gt;notebook&lt;/em&gt;, un'applicazione &lt;em&gt;web&lt;/em&gt; che consente di mescolare codice, risultati, visualizzazioni e testi in un unico documento. Qui entra in gioco &lt;a class="reference external" href="https://jupyter.org/"&gt;jupyter&lt;/a&gt;, progetto &lt;em&gt;open source&lt;/em&gt; di &lt;em&gt;notebook&lt;/em&gt; multi-linguaggio, che nell'ultima versione - &lt;code&gt;JupyterLab&lt;/code&gt; - integra anche un terminale e vari &lt;em&gt;plugin&lt;/em&gt; che lo rendono un vero e proprio ambiente &lt;em&gt;web&lt;/em&gt; interattivo di sviluppo. Sebbene i &lt;em&gt;notebook&lt;/em&gt;, estremamente versatili proprio per la capacità di integrare codice, testo e grafici in un unico documento, possano essere strumenti decisamente sofisticati in grado di generare un prodotto finito molto elegante, si prestano anche bene per le prime analisi esplorative e per costruire veloci prototipi di progetto, grazie all'immediatezza con cui in poche righe di codice si può caricare una tabella di dati, elaborarla e produrre qualche grafico a corredo.&lt;/p&gt;
&lt;p&gt;Il problema dei &lt;em&gt;notebook&lt;/em&gt; è che si prestano a uno stile di &lt;a class="reference external" href="https://it.wikipedia.org/wiki/Programmazione_imperativa"&gt;programmazione imperativo&lt;/a&gt; che rischia di produrre documenti "pasticciati" in caso di progetti più complessi e strutturati. Per questi ultimi, sono però disponibili strumenti che permettono di creare con relativa facilità delle vere e proprie applicazioni &lt;em&gt;web&lt;/em&gt; in cui risulta più semplice separare parametri e algoritmi e strutturare in modo più funzionale il codice. Tra questi strumenti, citerei in particolare &lt;a class="reference external" href="https://streamlit.io/"&gt;Streamlit&lt;/a&gt; che ho recentemente utilizzato per costruire una &lt;em&gt;dashboard&lt;/em&gt; nella quale riunire tutti i &lt;em&gt;task&lt;/em&gt; quotidiani in modo da avere un vero e proprio pannello di controllo delle attività ricorrenti nella mia giornata lavorativa. Quello che mi ha sorpreso di &lt;code&gt;Streamlit&lt;/code&gt; è l'assoluta facilità con cui è stato possibile integrare elementi interattivi nel codice per costruire pagine &lt;em&gt;web&lt;/em&gt; dinamiche; inoltre - ma questa è una caratteristica che condivide con molti altri pacchetti - come sia stato possibile costruire delle vere e proprie &lt;em&gt;web app&lt;/em&gt; solo con Python &lt;a class="footnote-reference brackets" href="https://marcobonifacio.github.io/posts/python-per-la-finanza/#id4" id="id2"&gt;2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Ecco, in sintesi questo è il mio ambiente di lavoro dietro lo schermo. Naturalmente, io sono un tipo curioso e ho provato molti altri strumenti in questi anni, prima di arrivare a una configurazione più o meno stabile che ho cercato qui di descrivere. E non è detto che non troverò qualcosa di interessante anche domani, per cui cambierò qualcosa e avrò una scusa per tornare a parlarne.&lt;/p&gt;
&lt;dl class="footnote brackets"&gt;
&lt;dt class="label" id="id3"&gt;&lt;span class="brackets"&gt;&lt;a class="fn-backref" href="https://marcobonifacio.github.io/posts/python-per-la-finanza/#id1"&gt;1&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;Anche se in realtà lo stesso risultato si può ottenere in miniconda settando il canale &lt;code&gt;conda-forge&lt;/code&gt; per primo.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class="label" id="id4"&gt;&lt;span class="brackets"&gt;&lt;a class="fn-backref" href="https://marcobonifacio.github.io/posts/python-per-la-finanza/#id2"&gt;2&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;Ovviamente, dietro c'è anche tanto Javascript, ma se ne occupa direttamente &lt;code&gt;Streamlit&lt;/code&gt; o chi per lui.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;&lt;/div&gt;</description><category>conda</category><category>jupyter</category><category>matplotlib</category><category>numpy</category><category>pandas</category><category>python</category><category>streamlit</category><guid>https://marcobonifacio.github.io/posts/python-per-la-finanza/</guid><pubDate>Mon, 03 May 2021 15:35:12 GMT</pubDate></item></channel></rss>